OICD = OpenID Connect

An oAuth Server
https://oauth2,thephpleague.com/
Google OAuth 2.0 Playground
https://developers.google.com/oauthplayground/

OAuth as a service
API Access Management
https://developer.okta.com/        

Token Introspection Extension
https://jwt.io
(or local libraries)
decode Jason Web Tokens (JWT),

The code for this course
========================
https://github.com/caseysoftware/oauth-and-openid-connect

Describing OAuth2.0
===================
Oauth is a framework for user to delegate access to 1 system over to another system
You are autorizing one system to act on behalf of you to that other system
You can do this to share data, functionality

Athentication (AuthN)
=====================
Who are you

Authorization (AuthZ)
=====================
What can you do

OAuth2 is an authorization framework

OpenID Connect is an OAuth 2.0 extension putting function and form to a users's profuile information.
OpenID Connect is a special case of OAuth2.0

Making OAuth 2.0 usefull with extensions
========================================

OAuth 2.0 Framework
Loose operating agreement, not a contract

Extensions
==========

1. OpenIdConnect 
Provides a standard way to request and share profile data
Gives us "Sign in with " on hundreds of sites
Derpends on JSON Web Tokens, or JWTs

2. Json Web Tokens (JWT)
RFC 7519
Oauth doesn't require JWTs, but they are commeon
JWTs are encoded, not encrypted
JSOM Web Encryption (JWE)
Includes:
iss (issuer)
iat (issued at)
sub (sunject)
aud (audience)
exp (expiration)

3. RFC 7662 Token IntrospectionExamines a token to describe tis contents
Useful for opaque tokens
Describes if the token is active or notMandatory if you have Tkoen Revocation

4. RFC 7009 Token Revocation
Revokes (cancels) a token via API
Technically optional
In prectice, required

RFC 8636 Auth Code with PKCE
(End user facing extension)
Usefulle for protecting  client-side flows (mobile devices, SPAs)
Rpleaces the implicit grant type

RFC 8693 Token Exchange
Introduces an approach for tradinbg or exchanging tokens on behalf of another  user or service, aka dlelegation.

RFC 8414 Authorization Server Metadata

OpenID Connect
==============
OIDC is an extensin on top of Oauth2.0
OIDC replaces SAML for Single Sign-On

OAuth 2.0 Fundamentals
======================
1. Resource owner - that is you
2. Resource server - what you are granting access to. Able to validate the token and allow requesting access
3. Grant type - how the application is asking for access
4. Scope - what access the application is requesting
5. Authorization server - who is the application asking for access - grant type and scope is sent to the authorization server
6. Token - how the application gets that access 
7. Claims - the content or information in the token

You (resource owner) want access to a room (the resource).
The front desk is the Authorization server.
Key card (token)

Undestanding the OAuth Endpoints
================================
RFC 6749: OAuth Core

/authorize
The endpoint taht the enduser (reresource owner interacts with togrant permission for the application to access the resource
Could retun n authorization code or a token

Evaluate our grant type and our scope request.

/token
The endpoint that the application uses to trade an autohrization code or refreshtoken for an accesstoken

The following endpoints are optional
====================================
/userinfo
The endpoint that applicatins use to retreive profile information about the authenticated user.

Returnt the claims about a user.

This returns a spec-defined set of fields, depending on the permissions (scope) requested.

RFC 8414. Oauth Authorization Server Metadata Discovery
The endpont that applications use to retrieve the configuration information fir the authorizationserver.

/introspect
The endpoint that applications 
TODO

/revoke

Grant types
===========
Authorization code
Implicit or hybrid
Resource Owner Password
Client Credentals
Device CodeAuthorization Code with PKCE

Are you authorizing on behalf of a user or a service?
Does the system in question have a web browser available?
In the application entirely server side, or does it have a clinet side component?

Oauth Scopres
=============
A set of permessions, you can request (example CRUD)

Example: okta.apps.read

OpenID Connect Scopes:
openid
profileemaik
address
phone

Using the OAuth Playground
==========================
https:developers.google.com&/oauthplayground

Oauth 2.0 tokens
================

1. Access token (Intended for the resource server)
The access token is a string representing an authorization issued to the client. This strong s usually opaque to the client.
Tokens represent specific scopes and durations of access, granted by the resource owner, and enforced by the resource server and autorization server.

- **Purpose**: Used to gain access to protected resources on behalf of the user. 
- **Usage**: Sent in API requests to authenticate and authorize access. 
- **Content**: Contains information like scopes, expiration, and other metadata required by the resource server to validate the token. 
- **Audience**: Intended for the resource server. 

2. Refresh token
A refresh token is a string representing the authorization granted to the client be the resource owner. The string is usually oopaque to the client. 
The token denotes an identifier used to retrieve the autorization information.

You can use a refresh token to request a new access token. Only for use with the authorization server


How is a token structured?
X. Opaque Tokens - there is nothing to see here.
Y. JSON Web Token (JWT) Full of authorizatin nd profile data.  Base 64 encoded string containing signature information to verify who sent it, and the data in it.

3. ID token (Intended for the client application)
The primary extension that OpenID Connect makes OAuth 2.0 to enbale End-Users to be Authenticated is the ID token data structure.
The ID token is a security token, that contains claims about the authentication of a end-user by an authorization server, when using a client, and potetially other requested claims.
The ID token is represented as a JSON Web Token (JWT).

- **Purpose**: Used to authenticate the user and provide information about the user. 
- **Usage**: Typically used in OpenID Connect (OIDC) to verify the user's identity. 
- **Content**: Contains claims about the user, such as their identity, authentication time, and other profile information. 
- **Audience**: Intended for the client application to validate the user's identity. 
 
In summary, an access token is used for authorization, while an ID token is used for authentication.
====================================================================================================

Validating JWTs
===============
Validating establishes trust - anything else is irresponsible.

Retrieve your signing keys - read the documentation from the OAuth provider. The public key of the sender.

3 parts separated by periods.

1. Header - tells us the algoritm used to generate the token.
2. Payload
3. Signature - Use the signing key to sign the payload and compare against the original structure.


Sign the payload using the public key of the sender. The result should mathc the signature received in the token.

The payload contains some key/value pairs called claims.

iss: Issuer of the token. Usually the Authorization server. Make sure this fild is what you expect.
sub: The entity ? the token is about. The enduser authenticated or the system, that requested the token.
aud: The inrended audience of the token. The application which requested the token.
iat: Issued at time

Check out https//jwt.io to find a library for toekn validation - matching the algoritm use need.

Handling Token Safely
=====================
Access and refresh tokena are credentials
Use TLS
Use Secure Cookies

ID token is going to the ownerDo not embed sensitive data
Use the token to retrieve sensitive infomation from the resource server directly.

Exchange  refresh token for en new acccess token.

4. Grant type. Authorization Code flow.
===================================
1. The user authenticates
2. The application (for example Web App, that the ser is using) authenticates

The autorization server now knows, who it granted a token to and for which app.

At no time did the application have the chance to touch our password
The user and the browser never had the chhance to touch the access token.

Onely the one-time-use authorization code is exposed,
The application never sees the user's credentials
The user never sees the access or refrsh tokens

User get back an auth code from the authorization server

The application uses the auth code and the client secret to get an access token (and optionally refresh token)

1. Authorization Code Request to /autorize (client sends)
2. 302 Redirect to authentification prompt (Authorization server sends)
3. Authentification and consent (client sends)
4. Authorization Code response (Authorization server sends)
5. Authorization Code and Client secret to /token (client sends)
6. Access token and optionally 
7.
8.




When should you use Authorization Code Flow
===========================================
Are you authorizing on behalf of a user?
Does the system in question have a webbrowser available?
Is the application entirely server side, or does it have a clietn side component?

Example
=======
The 3. part application never sees our credentilas 
and the end user never sees the access token.

https://github.com/caseysoftware/oauth-and-openid-connect


Postman:
Access Token
id_token

Postman:

Auth Url:          https://xxx/oauth/authorize
Access Token Url:  https://xxx/oauth/token

# Session 4.3: Using the Authorization Code Grant Type

Before using the following setup, ensure your Auth0 environment is configured as descibed in `other_oauth_server\README.md`. Because this Grant Type includes an interactive step, I recommend you use Postman or another visual client.

### Setting up Postman for Auth Code Flow using Auth0

For the Settings in this section, on your Auth0 Dashboard vist Applications > Applications and your specific application.

0. In the Postman request editor, immediately below the URL box, select Authorization.
0. For Type, select `OAuth 2.0`
0. For Auth URL, set it to your Auth0 domain (from the Settings tab) and append `/oauth/authorize`
0. For Access Token URL, use your Auth0 domain and append `/oauth/token`
0. For Client ID, use your Auth0 Client ID
0. For Client Secret, use your Auth0 Client Secret
0. For Scope, set `openid email`
0. Click "Get New Access Token"

If all goes well, you should see a redirect to your Auth0 login page. Log in with the credentials you created at setup and you should get back an `access_token` and `id_token`. Copy and paste either into jwt.io to see the decoded JWT.

Note: You may see an empty payload for the `access_token` which is okay. It depends on your configuration. The `id_token` will have your email information as specified by the `openid email` scopes. Change this to other OIDC scopes - like `openid profile` - to see how it changes.


https://jwt.io

Clear cookies. to see authorization.

Authorization Code. Husk. Yderligere 
====================================
1. Klik "Autheticate Using Browser" i postman
2. Kopier Postman Callback url til Auth server "Allowed Callback Urls"
3. PÃ¥ Auth Server i Advanced setting "Grant Types" skal "Authtification Code" enables.
4. Make sure your browser allows pop-ups

Auth-Code and PKCE overview
===========================
Singe Page Aps - loads them selves entirely client side in the browser or on a device.
We could not count on them to keep secrets for us.

Oauth is a framework, not a specification. We kan extend it.

No clinet secrets
No refresh tokens
RFC 7636 - Proof Key for Code Exchange

Authorization Code Flow with PKCE

It restores the Application Authentification step f
Security Considerations from the original Auto Code flow.

The App uses a PKCE code verifier to generate a challange

Send challange to /authorize

Send authorization code and code verifier to /token

The autho server uses the verifier to regenerate the original challange and compares them.

If they match, we know, that this is the app, that started the process - and atoken is teturned.

We managed to recreate App Authentification, without having to embed secrets in the app.

When should you uses PKCE?
==========================
You cannot trust a client application to keep secrets for us.
AppAuch appoiach: https://appauth.io/

Do we have a user - yes
Browser Available - yse
Server side only - yes.  Use Authorization Code Flow
Servider side only - no. Use Authorization Code Flow with PKCE.


https://auth0.com/docs/quickstart/spa/vanillajs/interactive

Example:
Our application is to be running on localhost:3000

Allowed Callback URL:
Here is a safe URL, that we plan on redirecting the user to, and there fore the token, after the autentificatin flows.

Allowed Logout URLs:
After the user logs out, we will redirect him back to this URL.

Allowed Web Origins:
This is a safe URL, that this flow might start from.

- **Public Clients**: Use this flow when developing public clients, such as mobile apps, desktop apps, or single-page applications (SPAs), where you cannot securely store a client secret. 
These applications are considered "public" because they run in environments where keeping secrets secure is not feasible. 
- **Enhanced Security**: PKCE (Proof Key for Code Exchange) adds an extra layer of security by requiring a dynamically generated code verifier and code challenge. 
This helps prevent attacks such as 
, even if the code is intercepted during the exchange process. 
- **Browser-Based Applications**: If you're developing an application that runs in a web browser and needs to authenticate users, 
using PKCE with the Authorization Code Flow is a secure choice. 

2. **Authentication**: The client secret is used in conjunction with the client ID to authenticate the client application when it requests an access token from the authorization server. 
This helps ensure that only authorized applications can obtain access tokens. 

Authorization Code Interception attacks
=======================================
An "authorization code interception" attack is a security threat in the OAuth 2.0 authorization process, specifically targeting the Authorization Code Flow. 
This type of attack occurs when an unauthorized party intercepts the authorization code that is sent from the authorization server to the client application. 
Here's how it can happen and why it matters:

### How It Happens:
1. **Redirect URI Manipulation**: An attacker may manipulate the redirect URI to capture the authorization code intended for the legitimate client. 
This can occur if the client application does not properly validate or restrict redirect URIs.

2. **Network Interception**: If the authorization code is transmitted over an insecure channel (e.g., HTTP instead of HTTPS), 
an attacker on the same network could intercept the code.

3. **Malicious Apps or Scripts**: An attacker might use malicious apps or scripts to intercept the authorization code,
 if the client application is running in an insecure environment.

### Why It's a Problem:
- **Impersonation**: Once an attacker has the authorization code, they can potentially exchange it for an access token at the authorization server, 
allowing them to impersonate the legitimate client application and access protected resources on behalf of the user.

### Mitigation Strategies:
- **Use HTTPS**: Always use HTTPS to encrypt communications between the client and the authorization server to prevent interception by network attackers.
  
- **PKCE (Proof Key for Code Exchange)**: Implement PKCE, especially for public clients like mobile apps or single-page applications. 
PKCE adds a layer of security by requiring the client to prove it is the legitimate recipient of the authorization code through a dynamically generated code verifier and code challenge.

- **Strict Redirect URI Validation**: Ensure that the authorization server only redirects authorization codes to pre-registered and validated redirect URIs.

- **Short-lived Codes**: Use short-lived authorization codes that expire quickly, reducing the window of opportunity for an attacker to use an intercepted code.

By implementing these strategies, you can significantly reduce the risk of authorization code interception attacks 
and protect user data and application integrity.


Security Considerations
=======================
It is only open when we have received the auth code, but not yet used it.
After the user autenticates, they get that auth code, which the server side app, then exchanges for the access token.
The auth code can only be used once.
The user or any other appplication in the browser cannot even see any of the resulting access tokens or refresh tokens.
Be aware of the users session
Protect your redirect_uri, which is where the oauh server will send tha auth code
You must validate your access token, with RFC 7519 or your oauth provider.

5. Grant Type. Resource Owner Code Flow
=======================================
