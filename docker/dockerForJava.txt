Aplications are packaged with the required infrastructure at the build phase.
curl localhost.8080/actuator/health
brew ls tomcat

A running image is called a container.

We have the entire infrastructure all the way down to operating system encapsulated into one self-contained unit. Hence the name container

Command line:
docker images
docker ps -a
docker stop my-demo-app
// Remove the container
docker rm my-demo-app 
// Remove the image
docker rmi my-demo-app 


# Se hvad der er i containere
docker exec -t -i my-demo-app /bin/sh
ls 
java -version
ls target
ls /usr/local/tomcat
ls /usr/local/tomcat/webapps

Containerization
================
Software is bundled with all it needs as one immutable artifact called an image.
The image defines all the dependencies it needs to run,
including any operating system files and libraries.

The image is identical, whether it is delivered to test staging or production.
It follows a spcification so that the runtime platform on test staging and production understands how to deploy it.
Identical images can be seamlessly swapped out or replicated at runtime,
making deployments resilient (?) and expandable.

OCI = Open Container Initiative
OCI image specification. The original Docker format.

OCI runtime specification: Docker and others.
This is the platform that unbundles the image and runs its contens in an isolated environment.

Comparing images to containers
==============================

Image:
Immutable object composed of files.
Operating environment and application run command.

Container runtime ad Engine
===========================
Platform for running images that follow the OCI image specification.

Container
=========
Also known as container image or Docker container.
The actual image of a running image.
A container is an instantiation of an image

Docker files
============
Image recipe card.

FROM base image
ADD, COPY, FROM, RUN, USER, VOLUME, WORKDIR
CMD or ENTRYPOINT

Docker CLI
==========
docker build: Creates an image
docker run: Instantiates an image as a container and runs it.

docker images: List images in local registry
docker ps: List active containers
docker exec: Run a command within a running container
docker system: General Docker system inspection

docker rmi:Remove image (no active containers)
docker stop. Stop a running contaner
docker rm: Remove a stopped container
docker system prune: Removed all unused or orphan images.

https://docs.docker.com/reference

docker --help

docker [commad] -- help

Learn Dockerfile instructions
=============================
alpine is a slimmed down image of a Linux operating system.

There is a default Docker image registry called Docker Hub (Just like Maven Central).

https://hub.docker.com
https://hub.docker.com/_/alphine

docker build .
docker images
docker run --name os-app [IMAGE_ID]

docker ps -a
docker rm os-app
docker rmi [IMAGE_ID]
docker images

docker build -t hello .
ducker run --name hello-app hello


FROM openjdk:11-jdk
ADD app /app
WORKDIR /app
RUN javac -cp lombok.jar Forever.java
CMD ["java", "Forever", "-cp", "lombok.jar"]

// Compile
javac -cp lombok.jar Forver.java

--detach

Convert code to a Docker Image
==============================

docker logs foreverbuilder-app

docker exec -t- i foreverbuilder-app ls /app

docker exec -t- i foreverbuilder-app ls /bin/sh

docker system prune -a  // Delete any a images that don not have a running image


# Build the image
docker build -t foreverbuilder -f Dockerfile-build .
# Run the container
docker run --detach -name foreverbuilder-app foreverbuilder

C:\work\docker-for-java-developers-2452212\dockerfile-demos\runapp

# Command to start a shell
docker exec -t- i foreverbuilder-app ls /bin/sh

# Example
=========
FROM openjdk:11-jdk
ADD app /app
WORKDIR /app
RUN javac -cp lombok.jar Forever.java
RUN rm Forever.java
RUN if [ -f ./Forever.java ]; then \
        echo "File exists!"; \
    else \
        echo "File does not exist!"; \
    fi
CMD ["java", "Forever", "-cp", "lombok.jar"]


Best practices
==============
Import lightest (less alyers)( image possible
Start with stable, verfied non changing version images
Only add files you need.
Order Dockerfile from least to most frequently changed.


Bad
===
FROM alpine:latest
ADD ./ /app/
RUN apk add openjdk11 	// Pulls down the openjdk11
WORKDIR /app
CMD ["java", "-jar", "target/layerdemo-0.0.1-SNAPSHOT.jar"]

Alpine; latest could changed
Does not start with an image, that combineds the OS and Java
We wre adding the entire app folder, instead of just the jar. Add only the JAR file, not the whoe project.
Add JAR file right before the CMD. We add the folder before, we build the ja, so the folder needs to be build again
Use JRE instead of JDK

Good
====
# Best Practices

# Using a version tagged starting image
# Combined OS and Java Run Time
# JRE instead of JDK
FROM openjdk:11-jre-slim

# Does not change, Moved to Second instruction
WORKDIR /app

# Added only Jar file
# Added Jar file right before use
ADD target/layerdemo-0.0.1-SNAPSHOT.jar /app/

CMD ["java", "-jar", "layerdemo-0.0.1-SNAPSHOT.jar"]


















