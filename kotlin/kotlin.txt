Online playground: try.kotlinglang.org
See koans
Advent of code

Type System
===========
Val-  creates in immutable declaration
Var - is used for a mutable declaration

The only type we nedd to specify the type a variable is when the compiler is unable to determine it.

When we do not give the variable a definition,we must give it a type

var myLong = 123456L
var myShort: Short = 12
var myByte: Byte = 127

val anInt: Int = 1
val aLong: Long = anInt.toLong()

Control flow - if
=================
If is an expression in Kotlin, not a statement (as it is in Java).

Statement:Program instructions that return no value; can't be on the right side of on equasl sign.
Expression: Program instructions that return values; can be on the right side of on equasl sign.

// int lowest = (a<b) ? a : b;    // Java

val lowest = if (myInt < anInt) myInt else anInt;
println("The lowest value is $lowest");

Control flow - when
===================
case -> when

Control flow - loops
====================
Kotlinns for statement works in conjunctuin with any type, that has an iterator

for (item in 1..10) = {
   println ("$item, ")
}

for (ch in "busquit") = {
 }

Control flow - - advanced loops
===============================
vard ndx = 0

for (item in 10.rangeTo(20).step(2)) {
   println("${++ndx}) $item, ")
}
println


for ((index, item) in 10.rangeTo(20).step(2).withIndex()) {
   println("${index+1}) $item, ")
}
println

val myArray = arrayOf()10,20,30)
for (item in myArray.indces) {
   println("At index $Item is ${myArray[item]}")
}
println


Functions
=========

Expression fuunction:
fun pplus(param1: Int, param2: Int): Int = param1 + pramm2

fun pplus(param1: Int, param2: Int) = param1 + pramm2

named arguments

Objects
=======
val location object {
var xPosistion = 200

fun printIt(
}

}

object type, see above

object declaration: is a statement not an expression

object MySingleton {
   var temperatures = arrafOf(80, 76, 90)
   fuc getLatTemperature = temperatures.last()
   
}   

val temperatures = MySingleton.getLatTemperature()

Interfaces
==========
interface Vehicle {
   val MakeName: String
   fun go() {}
}

Generics
========
Put an upper bound on our functions type parameter

package com.tekadept.demo

// Add your solution here
fun <T: Comparable<T>> getSmaller(param1: T, param2: T): T {
    val result = param1.compareTo(param2)
    return if(result >0) param2 else param1
}

fun main(args: Array<String>) {
    println("getSmaller")

    // Please add the getSmaller function above the main function
    val minInt: Int = getSmaller(42, 99)
    val minDouble: Double = getSmaller(9.807, 3.14159)
    val minString: String = getSmaller("kitten", "kittens")

    println("The min Int = $minInt")
    println("The min Double = $minDouble")
    println("The min String = $minString")
}


val maxInt: Int = max(42, 99)

Use Java from Kotlin
====================
fun JavaIterop() {
   val Frisky = Animal("Frisky", "cat", 10)
   println(Frisky.Show())
   Frisky.weight = 15
}

Use Kotlin from Java
====================

public class HelloWorld {
   public static void main(String [] args) {
   
   }
   
   Person Bog = new Person ("Robert", "Smith")
   System.out.println(Bob.getFirstName())
   
   Bob.setFirstName("Bob");
 
   // Name of the Kotlin file 
   Integer maxInt = MaxKt.max(2001, 2010)
}

Operator overloading
====================
Operators are functions, that use symbolic names

We can create our own functions for symbols in classes.
This is called oprator overloading.

data class Position(var x: Int, var y: Int) {
   operator fun plus(other: Position) : Position {
      return Position(x + other x), y + other.y)
   }
}

Annotations
===========
Annotation are a way to attach metadata to code

Reflection
==========
Reflections allows us to access programmatic information dynamicly at runtime.

val Joe = Person("Joe", "Smith")
val kClass = Joe.javaClass.kotlin
println("Simple name = ${kClass.simplename}")

//  Add kotin-reflect.jar to the classpath
/// Simple name = person

for  (name in kClass.memberproperties) {
   println("Property name = $name)
    println("Property name = {$name.name )}
}

DSL
===
TODO









