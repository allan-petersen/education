Online playground: try.kotlinglang.org
See koans
Advent of code

Type System
===========
Val-  creates in immutable declaration
Var - is used for a mutable declaration

The only type we nedd to specify the type a variable is when the compiler is unable to determine it.

When we do not give the variable a definition,we must give it a type

var myLong = 123456L
var myShort: Short = 12
var myByte: Byte = 127

val anInt: Int = 1
val aLong: Long = anInt.toLong()

Control flow - if
=================
If is an expression in Kotlin, not a statement (as it is in Java).

Statement:Program instructions that return no value; can't be on the right side of on equasl sign.
Expression: Program instructions that return values; can be on the right side of on equasl sign.

// int lowest = (a<b) ? a : b;    // Java

val lowest = if (myInt < anInt) myInt else anInt;
println("The lowest value is $lowest");

Control flow - when
===================
case -> when

Control flow - loops
====================
Kotlinns for statement works in conjunctuin with any type, that has an iterator

for (item in 1..10) = {
   println ("$item, ")
}

for (ch in "busquit") = {
 }

Control flow - - advanced loops
===============================
vard ndx = 0

for (item in 10.rangeTo(20).step(2)) {
   println("${++ndx}) $item, ")
}
println


for ((index, item) in 10.rangeTo(20).step(2).withIndex()) {
   println("${index+1}) $item, ")
}
println

val myArray = arrayOf()10,20,30)
for (item in myArray.indces) {
   println("At index $Item is ${myArray[item]}")
}
println


Functions
=========

Expression fuunction:
fun pplus(param1: Int, param2: Int): Int = param1 + pramm2

fun pplus(param1: Int, param2: Int) = param1 + pramm2

named arguments

Unit is Kotlins version of a Java void

infix keyword: It allows us to move the function in between its paramters (like +)


Objects
=======
val location object {
var xPosistion = 200

fun printIt(
}

}

object type, see above

object declaration: is a statement not an expression

object MySingleton {
   var temperatures = arrafOf(80, 76, 90)
   fuc getLatTemperature = temperatures.last()
   
}   

val temperatures = MySingleton.getLatTemperature()

Interfaces
==========
interface Vehicle {
   val MakeName: String
   fun go() {}
}

Generics
========
Put an upper bound on our functions type parameter

package com.tekadept.demo

// Add your solution here
fun <T: Comparable<T>> getSmaller(param1: T, param2: T): T {
    val result = param1.compareTo(param2)
    return if(result >0) param2 else param1
}

fun main(args: Array<String>) {
    println("getSmaller")

    // Please add the getSmaller function above the main function
    val minInt: Int = getSmaller(42, 99)
    val minDouble: Double = getSmaller(9.807, 3.14159)
    val minString: String = getSmaller("kitten", "kittens")

    println("The min Int = $minInt")
    println("The min Double = $minDouble")
    println("The min String = $minString")
}


val maxInt: Int = max(42, 99)

Use Java from Kotlin
====================
fun JavaIterop() {
   val Frisky = Animal("Frisky", "cat", 10)
   println(Frisky.Show())
   Frisky.weight = 15
}

Use Kotlin from Java
====================

public class HelloWorld {
   public static void main(String [] args) {
   
   }
   
   Person Bog = new Person ("Robert", "Smith")
   System.out.println(Bob.getFirstName())
   
   Bob.setFirstName("Bob");
 
   // Name of the Kotlin file 
   Integer maxInt = MaxKt.max(2001, 2010)
}

Operator overloading
====================
Operators are functions, that use symbolic names

We can create our own functions for symbols in classes.
This is called oprator overloading.

data class Position(var x: Int, var y: Int) {
   operator fun plus(other: Position) : Position {
      return Position(x + other x), y + other.y)
   }
}

Annotations
===========
Annotation are a way to attach metadata to code

Reflection
==========
Reflections allows us to access programmatic information dynamicly at runtime.

val Joe = Person("Joe", "Smith")
val kClass = Joe.javaClass.kotlin
println("Simple name = ${kClass.simplename}")

//  Add kotin-reflect.jar to the classpath
/// Simple name = person

for  (name in kClass.memberproperties) {
   println("Property name = $name)
    println("Property name = {$name.name )}
}

DSL
===
is a computer language which is focuesed on a very narrow problem set.


interface Matcher<T> {
   fun test(lhs: T): Unit
   
   infix fun or(other: Matcher<T>) Matcher<T> = object : Matcher<T> {
      override fun test(lhs: T) {
	     try {
	        this$Matcher.test(lhs)
		 } catch(e: RuntimeException) {
		    other.test(lhs)
		 }
	  }
   }   
}

// Should for a single object
infix fun <T> T.should(matcher: Matcher<T>) {
   // Test the current object
   matcher.test(this)
}

// Should for a collection
// fn for function
infix fun <T> Collection<T>.should(fn: CollectionMatchers<T>.()-> Unit) {
   val matchers = CollectionMatchers(this)
   // Call the function that got passed into us
   matchers.fn()
}

// CollectionMatcher class. This class holds the clause , which comes after the word should
class CollectionMatcher<T> (val collection: Collection<T>) {
   fun contains(rhs: T) : Unit {
      if (!collection.contains(rhs))
	     throw RuntimException("Collection did not contain $rhs")
   }
   
   fun notContain(rhs: T) : Unit {
      if (collection.contains(rhs))
	     throw RuntimException("Collection should not contain $rhs")
   }
   
   fun haveSizeLessThan(size: Int) : Unit {
      if (collection.size >= size)
	     throw RuntimException("Collection should have size less than $size")
   }
}

func unitTest() {
   val listOfNames = listOfÂ¨("April", "May", "June")
   // There are several ways to obtain an instance of a function type:
   // Use a code block within a function literal, in one of the following forms:
   // a lambda expression: { a, b -> a + b },
   // ... See https://kotlinlang.org/docs/lambdas.html#instantiating-a-function-type
   listOfNames should { notContain("Portia") }
   
}





 
















